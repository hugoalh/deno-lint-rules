import {
	NodeMemberExpressionMatcher,
	type RuleData
} from "../_utility.ts";
const mems: readonly NodeMemberExpressionMatcher[] = [
	"AbortController",
	"AbortSignal",
	"addEventListener",
	"AggregateError",
	"alert",
	"Array",
	"ArrayBuffer",
	"atob",
	"Atomics",
	"Blob",
	"Boolean",
	"BroadcastChannel",
	"btoa",
	"ByteLengthQueuingStrategy",
	"Cache",
	"caches",
	"CacheStorage",
	"cancelAnimationFrame",
	"CanvasGradient",
	"CanvasPattern",
	"clearInterval",
	"clearTimeout",
	"close",
	"CloseEvent",
	"confirm",
	"console",
	"CountQueuingStrategy",
	"createImageBitmap",
	"crossOriginIsolated",
	"crypto",
	"Crypto",
	"CryptoKey",
	"CustomEvent",
	"Deno",
	"dispatchEvent",
	"DOMException",
	"DOMMatrix",
	"DOMMatrixReadOnly",
	"DOMPoint",
	"DOMPointReadOnly",
	"DOMQuad",
	"DOMRect",
	"DOMRectReadOnly",
	"DOMStringList",
	"ErrorEvent",
	"Event",
	"EventSource",
	"EventTarget",
	"fetch",
	"IDBFactory",
	"IDBIndex",
	"IDBKeyRange",
	"IDBObjectStore",
	"IDBOpenDBRequest",
	"IDBRequest",
	"IDBTransaction",
	"IDBVersionChangeEvent",
	"ImageBitmap",
	"ImageBitmapRenderingContext",
	"ImageData",
	"indexedDB",
	"isSecureContext",
	"MediaCapabilities",
	"MessageChannel",
	"MessageEvent",
	"MessagePort",
	"name",
	"navigator",
	"NetworkInformation",
	"Notification",
	"onerror",
	"onlanguagechange",
	"onmessage",
	"onmessageerror",
	"onoffline",
	"ononline",
	"onrejectionhandled",
	"onunhandledrejection",
	"origin",
	"Path2D",
	"performance",
	"Performance",
	"PerformanceEntry",
	"PerformanceMark",
	"PerformanceMeasure",
	"PerformanceObserver",
	"PerformanceObserverEntryList",
	"PerformanceResourceTiming",
	"PerformanceServerTiming",
	"Permissions",
	"PermissionStatus",
	"postMessage",
	"ProgressEvent",
	"PromiseRejectionEvent",
	"prompt",
	"PushManager",
	"PushSubscription",
	"PushSubscriptionOptions",
	"queueMicrotask",
	"ReadableStream",
	"ReadableStreamDefaultController",
	"ReadableStreamDefaultReader",
	"removeEventListener",
	"Request",
	"requestAnimationFrame",
	"Response",
	"SecurityPolicyViolationEvent",
	"ServiceWorker",
	"ServiceWorkerContainer",
	"ServiceWorkerRegistration",
	"setInterval",
	"setTimeout",
	"StorageManager",
	"SubtleCrypto",
	"TextDecoder",
	"TextDecoderStream",
	"TextEncoder",
	"TextEncoderStream",
	"TextMetrics",
	"TransformStream",
	"TransformStreamDefaultController",
	"undefined",
	"URL",
	"URLSearchParams",
	"WebAssembly",
	"WebGL2RenderingContext",
	"WebGLActiveInfo",
	"WebGLBuffer",
	"WebGLContextEvent",
	"WebGLFramebuffer",
	"WebGLProgram",
	"WebGLQuery",
	"WebGLRenderbuffer",
	"WebGLRenderingContext",
	"WebGLSampler",
	"WebGLShader",
	"WebGLShaderPrecisionFormat",
	"WebGLSync",
	"WebGLTexture",
	"WebGLTransformFeedback",
	"WebGLUniformLocation",
	"WebGLVertexArrayObject",
	"WebSocket",
	"Worker",
	"WritableStream",
	"WritableStreamDefaultController",
	"WritableStreamDefaultWriter",
	"XMLHttpRequest",
	"XMLHttpRequestEventTarget",
	"XMLHttpRequestUpload"
].map((value: string): NodeMemberExpressionMatcher => {
	return new NodeMemberExpressionMatcher([value], true);
});
export const ruleData: RuleData = {
	identifier: "no-useless-global-prefix",
	querier(): Deno.lint.Rule {
		return {
			create(context: Deno.lint.RuleContext): Deno.lint.LintVisitor {
				return {
					MemberExpression(node: Deno.lint.MemberExpression): void {
						if (!node.computed && !node.optional && mems.some((mem: NodeMemberExpressionMatcher): boolean => {
							return mem.test(node);
						})) {
							const replacementText: string = context.sourceCode.getText(node.property);
							context.report({
								node,
								message: `Use via the globals object(s) is forbidden.`,
								hint: `Do you mean \`${replacementText}\`?`,
								fix(fixer: Deno.lint.Fixer): Deno.lint.Fix | Iterable<Deno.lint.Fix> {
									return fixer.replaceText(node, replacementText);
								}
							});
						}
					}
				};
			}
		};
	}
};
